<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
  background-color: #bfd1e5;
  margin: 0px;
  overflow: hidden;
}
#download-button {
  bottom: 1vmax;
  height: 5vmax;
  position: absolute;
  right: 1vmax;
  width: 5vmax;
}
#download-button:not([href]) {
  display: none;
}
svg .a{fill:#7396c2;}
svg .b{opacity:0.2;}
svg .c{fill:#231f20;}
svg .d{fill:white;}
</style>
</head>
<body>

<div id="container"></div>
<a id="download-button" href="#"><svg x="0px" y="0px" viewBox="0 0 64 64" style="enable-background:new 0 0 64 64;"><g><g><circle class="a" cx="32" cy="32" r="32"/></g><g class="b"><path class="c" d="M47.8,30H40V18c0-2.2-1.8-4-4-4h-8c-2.2,0-4,1.8-4,4v12h-7.8c-2.7,0-3.5,1.9-1.7,4.1l14.3,18.1 c1.8,2.3,4.7,2.3,6.5,0l14.3-18.1C51.3,31.9,50.6,30,47.8,30z"/></g><g><path class="d" d="M24,16c0-2.2,1.8-4,4-4h8c2.2,0,4,1.8,4,4v24c0,2.2-1.8,4-4,4h-8c-2.2,0-4-1.8-4-4V16z"/></g><g><path class="d" d="M47.8,28c2.7,0,3.5,1.9,1.7,4.1L35.3,50.3c-1.8,2.3-4.7,2.3-6.5,0L14.5,32.1c-1.8-2.3-1-4.1,1.7-4.1H47.8z"/></g></g></svg></a>

<script src="//threejs.org/build/three.min.js"></script>
<script src="//threejs.org/examples/js/controls/OrbitControls.js"></script>
<script type="text/javascript">

THREE.ImageDataLoader = (function () {
  
  /* Accumulates data, adding resolution every turn.
   */
  function Accumulator(length, offsets, scales) {
    var noff = offsets.length;
    var translation = offsets.map(function(o){return -o;});
    
    var data = new Float32Array(length);
    
    for (var i=0, l=data.length; i<l; i+=noff) {
      data.set(translation, i);
    }
    
    return {
      /* The data array.
       */
      data: data,
      
      /* Processes new data and adds to existing values.
       */
      addData: function (new_data, index, strides) {
        var new_data_scale = scales.map(function (s) {
          return Math.pow(2, s - index * 8 - 8);
        });
        strides = strides || 4; // Default: RGBA.
        for (var i=0, j=0; i<length; i+=noff, j+=strides) {
          for (var k=0; k<noff; k++) {
            data[i+k] += new_data[j+k] * new_data_scale[k];
          }
        }
      },
      
      /* Adds RGBA pixel values to data.
       */
      addImageData: function (image, index) {
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        var d = context.getImageData(0, 0, image.width, image.height).data;
        this.addData(d, index, 4);
      }
    }
  }
  
  //
  
  /* Loads array data from pixel values over multiple images.
   */
  function ImageDataLoader(manager) {
    this.manager = (manager !== undefined) ?
                    manager : THREE.DefaultLoadingManager;
  }
  
  Object.assign(ImageDataLoader.prototype, {
    constructor: ImageDataLoader,
    crossOrigin: 'Anonymous',
    
    load: function (urls, params, onLoad, onProgress, onError) {
      var npix = params.resolution[0] * params.resolution[1];
      var noff = params.offset.length;
      var acc = new Accumulator(npix * noff, params.offset, params.scale);
      var loader = new THREE.ImageLoader(this.manager);
      var loading = 0;
      
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      
      if (typeof urls === 'string') {
        urls = [urls];
      }
      
      loading = urls.length;
      
      urls.forEach(function (url, index) {
        loader.load(url, function (image) {
        
          acc.addImageData(image, index);
          
          if (onProgress !== undefined) {
            onProgress(acc.data);
          }
          if (--loading === 0) {
            onLoad(acc.data);
            delete acc;
          }
        }, undefined, onError);
      });
    },

    setCrossOrigin: function (value) {
      this.crossOrigin = value;
      return this;
    },
    
    setPath: function (value) {
      this.path = value;
      return this;
    }
  });
  
  return ImageDataLoader;
})();



THREE.MapLoader = (function () {
  
  /* Loads .map files and linked assets to create a textured mesh.
   */
  function MapLoader(manager) {
    this.manager = (manager !== undefined) ?
                    manager : THREE.DefaultLoadingManager;
  }
  
  Object.assign(MapLoader.prototype, {
    constructor: MapLoader,
    withCredentials: false,
    
    load: function (url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new THREE.FileLoader(this.manager);
      
      loader.setPath(this.path);
      loader.setWithCredentials(this.withCredentials);
      
      loader.load(url, function(text) {
        var json = JSON.parse(text);
        var mesh = scope.parse(json);
        if (onLoad !== undefined)
          onLoad(mesh);
      }, onProgress, onError);
    },
    
    parse: function (json) {
      var texture = new THREE.TextureLoader(this.manager);
      var material = new THREE.MeshBasicMaterial();
      
      texture.setPath(this.path);
      material.map = texture.load(json.texture);
      
      var shape = new THREE.ImageDataLoader(this.manager);
      var geometry = new THREE.PlaneBufferGeometry(
        1 << json.scale[0] - 1,  // scale is the number of bits storing the
        1 << json.scale[1] - 1,  // integer part for each float. This value
        json.resolution[0] - 1,  // differs for x, y and z coordinates.
        json.resolution[1] - 1
      );
      
      shape.setPath(this.path);
      shape.load(json.shape, json, finalizeGeometry, updateGeometry);
      
      return new THREE.Mesh(geometry, material);
      
      function updateGeometry(data) {
        geometry.attributes.position.array.set(data);
        geometry.attributes.position.needsUpdate = true;
      }
      
      function finalizeGeometry(data) {
        geometry.attributes.position;
        geometry.computeBoundingBox();
        geometry.computeVertexNormals();
      }
    },
    
    setPath: function (value) {
      this.path = value;
      return this;
    },
    
    setWithCredentials: function (value) {
      this.withCredentials = value;
      return this;
    }
  });
  
  return MapLoader;
})();
</script>
<script type="text/javascript">
var root = '//files.facer2vm.org/view/';
root = 'data/';

var camera;
var controls;
var renderer;
var scene;

var clock = new THREE.Clock();

init();
animate();

function init() {
  var container = document.getElementById('container');
  var download = document.getElementById('download-button');
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xbfd1e5);
  
  if (location.hash) {
    var loader = new THREE.MapLoader();
    var name = location.hash.substr(1).match(/[\w-]*/)[0];
    var mapfile = name + '.map';
    var zipfile = name + '.zip';
    loader.setPath(root);
    loader.load(mapfile, function (mesh) {scene.add(mesh);});
    download.href = root + zipfile;
  }
  
  camera = new THREE.PerspectiveCamera(50, 4/3, 1, 20000);
  camera.position.z = 400;
  camera.up = new THREE.Vector3(0, 1, 0);
  camera.lookAt(scene.position);
  
  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(400, 300);
  
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.addEventListener('change', render);
  
  container.innerHTML = '';
  container.appendChild(renderer.domElement);
  
  window.addEventListener('resize', onWindowResize, false);
  onWindowResize();
}

function onWindowResize() {
  var w = window.innerWidth;
  var h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  //controls.handleResize();
}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {
  //controls.update(clock.getDelta());
  renderer.render(scene, camera);
}
</script>

</body>
</html>
